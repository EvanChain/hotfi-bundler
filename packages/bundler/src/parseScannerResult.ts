import {
  EntryPoint, IAccount__factory,
  IEntryPoint__factory,
  IPaymaster__factory, SenderCreator__factory
} from '@account-abstraction/contracts'
import { hexZeroPad, Interface, keccak256 } from 'ethers/lib/utils'
import { BundlerCollectorReturn, ExitInfo, MethodInfo, TopLevelCallInfo } from './BundlerCollectorTracer'
import { mapOf, requireCond } from './utils'
import { inspect } from 'util'

import Debug from 'debug'
import { mergeStorageMap, toBytes32 } from './modules/moduleUtils'
import { ValidationResult } from './modules/ValidationManager'
import { BigNumber, BigNumberish } from 'ethers'
import { TestOpcodesAccountFactory__factory, TestOpcodesAccount__factory, TestStorageAccount__factory } from './types'
import { StakeInfo, StorageMap, UserOperation, ValidationErrors } from './modules/Types'
import assert from 'assert'

const debug = Debug('aa.handler.opcodes')

interface CallEntry {
  to: string
  from: string
  type: string // call opcode
  method: string // parsed method, or signash if unparsed
  revert?: any // parsed output from REVERT
  return?: any // parsed method output.
  value?: BigNumberish
}

export interface ParsedTracerResults {
  storageMap: StorageMap
  addresses: string[]
  gasUsed: number
}

/**
 * parse all call operation in the trace.
 * notes:
 * - entries are ordered by the return (so nested call appears before its outer call
 * - last entry is top-level return from "simulateValidation". it as ret and rettype, but no type or address
 * @param tracerResults
 */
function parseCallStack (calls: Array<ExitInfo | MethodInfo>): CallEntry[] {
  const abi = Object.values([
    ...TestOpcodesAccount__factory.abi,
    ...TestOpcodesAccountFactory__factory.abi,
    ...TestStorageAccount__factory.abi,
    ...SenderCreator__factory.abi,
    ...IEntryPoint__factory.abi,
    ...IPaymaster__factory.abi
  ].reduce((set, entry) => {
    const key = `${entry.name}(${entry.inputs.map(i => i.type).join(',')})`
    // console.log('key=', key, keccak256(Buffer.from(key)).slice(0,10))
    return {
      ...set,
      [key]: entry
    }
  }, {})) as any

  const xfaces = new Interface(abi)

  function callCatch<T, T1> (x: () => T, def: T1): T | T1 {
    try {
      return x()
    } catch {
      return def
    }
  }

  const out: CallEntry[] = []
  const stack: any[] = []
  calls
    .filter(x => !x.type.startsWith('depth'))
    .forEach(c => {
      if (c.type.match(/REVERT|RETURN/) != null) {
        const top = stack.splice(-1)[0] ?? {
          type: 'top',
          method: 'validateUserOp'
        }
        const returnData: string = (c as any).data
        if (top.type.match(/CREATE/) != null) {
          out.push({
            to: top.to,
            from: top.from,
            type: top.type,
            method: '',
            return: `len=${returnData.length}`
          })
        } else {
          const method = callCatch(() => xfaces.getFunction(top.method), top.method)
          if (c.type === 'REVERT') {
            const parsedError = callCatch(() => xfaces.parseError(returnData), returnData)
            out.push({
              to: top.to,
              from: top.from,
              type: top.type,
              method: method.name,
              value: top.value,
              revert: parsedError
            })
          } else {
            const ret = callCatch(() => xfaces.decodeFunctionResult(method, returnData), returnData)
            out.push({
              to: top.to,
              from: top.from,
              type: top.type,
              value: top.value,
              method: method.name ?? method,
              return: ret
            })
          }
        }
      } else {
        stack.push(c)
      }
    })

  // TODO: verify that stack is empty at the end.

  return out
}

interface EntitySlots {
  [addr: string]: Set<string>
}

/**
 * slots associated with each entity.
 * keccak( A || ...) is associated with "A"
 * removed rule: keccak( ... || ASSOC ) (for a previously associated hash) is also associated with "A"
 *
 * @param stakeInfoEntities stake info for (factory, account, paymaster). factory and paymaster can be null.
 * @param keccak array of buffers that were given to keccak in the transaction
 */
function parseEntitySlots (stakeInfoEntities: Array<StakeInfo | undefined>, keccak: string[]): EntitySlots {
  // for each entity (sender, factory, paymaster), hold the valid slot addresses
  // valid: the slot was generated by keccak(entity || ...)
  const entitySlots: { [addr: string]: Set<string> } = {}

  keccak.forEach(k => {
    stakeInfoEntities.forEach(info => {
      const addr = info?.addr?.toLowerCase()
      if (addr == null) return
      const addrPadded = toBytes32(addr)
      if (entitySlots[addr] == null) {
        entitySlots[addr] = new Set<string>()
      }

      const currentEntitySlots = entitySlots[addr]

      // valid slot: the slot was generated by keccak(entityAddr || ...)
      if (k.startsWith(addrPadded)) {
        // console.log('added mapping (balance) slot', value)
        currentEntitySlots.add(keccak256(k))
      }
    })
  })

  return entitySlots
}

// method-signature for calls from entryPoint
export const callMethodSig = {
  factory: SenderCreator__factory.createInterface().getSighash('createSender'),
  account: IAccount__factory.createInterface().getSighash('validateUserOp'),
  paymaster: IPaymaster__factory.createInterface().getSighash('validatePaymasterUserOp')
}

/**
 * validate the after creating a full handleOps bundle, the UserOps are still working within their sandbox.
 * @param userOps the userOperation that was used in this simulation
 * @param tracerResults the tracer return value
 * @param entryPoint the entryPoint that hosted the "simulatedValidation" traced call.
 * @return list of contract addresses referenced by this UserOp
 */
export function parseHandleOpsTraceResult (userOps: UserOperation[], tracerResults: BundlerCollectorReturn, entryPoint: EntryPoint): ParsedTracerResults {
  let count = 0

  let storageMap: StorageMap = {}
  const addresses = new Set<string>()
  for (const userOp of userOps) {
    const callInfo: TopLevelCallInfo[] = []
    if (userOp.initCode.length > 2) {
      callInfo.push(tracerResults.callsFromEntryPoint[count++])
    }
    const callToValidateUserOp = tracerResults.callsFromEntryPoint[count++]
    assert(callToValidateUserOp.topLevelMethodSig === callMethodSig.account,
      'Invalid methodSig: expected validateUserOp, not ' + callToValidateUserOp.topLevelMethodSig)
    callInfo.push(callToValidateUserOp)
    if (userOp.paymasterAndData.length > 2) {
      const callToValidatePaymasterUserOp = tracerResults.callsFromEntryPoint[count++]
      assert(callToValidatePaymasterUserOp.topLevelMethodSig === callMethodSig.paymaster,
        'Invalid methodSig: expected validatePaymasterUserOp, not ' + callToValidatePaymasterUserOp.topLevelMethodSig)
      callInfo.push(callToValidatePaymasterUserOp)
    }
    const [addrs, storage] = parseScannerResult1(userOp, callInfo, tracerResults.keccak, null, entryPoint)
    storageMap = mergeStorageMap(storageMap, storage)
    addrs.forEach(addr => addresses.add(addr))
  }
  return {
    storageMap,
    addresses: [...addresses.keys()],
    gasUsed: tracerResults.gas
  }
}

/**
 * parse collected simulation traces and revert if they break our rules
 * @param userOp the userOperation that was used in this simulation
 * @param tracerResults the tracer return value
 * @param validationResult output from simulateValidation
 * @param entryPoint the entryPoint that hosted the "simulatedValidation" traced call.
 * @return list of contract addresses referenced by this UserOp
 */
export function parseSimulationTraceResults (userOp: UserOperation, tracerResults: BundlerCollectorReturn, validationResult: ValidationResult, entryPoint: EntryPoint): [string[], StorageMap] {
  debug('=== simulation result:', inspect(tracerResults, true, 10, true))
  return parseScannerResult1(userOp, tracerResults.callsFromEntryPoint, tracerResults.keccak, validationResult, entryPoint)
}

const bannedOpCodes = new Set(['GASPRICE', 'GASLIMIT', 'DIFFICULTY', 'TIMESTAMP', 'BASEFEE', 'BLOCKHASH', 'NUMBER', 'SELFBALANCE', 'BALANCE', 'ORIGIN', 'GAS', 'CREATE', 'COINBASE', 'SELFDESTRUCT', 'RANDOM', 'PREVRANDAO'])

export function parseScannerResult1 (userOp: UserOperation, callsFromEntryPoint: TopLevelCallInfo[], keccakInputs: string[], validationResult: ValidationResult | null, entryPoint: EntryPoint): [string[], StorageMap] {
  // todo: block access to no-code addresses (might need update to tracer)

  const entryPointAddress = entryPoint.address.toLowerCase()

  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  if (Object.values(callsFromEntryPoint).length < 1) {
    throw new Error('Unexpected traceCall result: no calls from entrypoint.')
  }
  const callStack = parseCallStack(callsFromEntryPoint.flatMap(level => level.calls))

  const callInfoEntryPoint = callStack.find(call =>
    call.to === entryPointAddress && call.from !== entryPointAddress &&
    (call.method !== '0x' && call.method !== 'depositTo'))
  requireCond(callInfoEntryPoint == null,
    `illegal call into EntryPoint during validation ${callInfoEntryPoint?.method}`,
    ValidationErrors.OpcodeValidation
  )

  const illegalNonZeroValueCall = callStack.find(
    call =>
      call.to !== entryPointAddress &&
      !BigNumber.from(call.value ?? 0).eq(0))
  requireCond(
    illegalNonZeroValueCall == null,
    'May not may CALL with value',
    ValidationErrors.OpcodeValidation)

  const entitySlots = parseEntitySlots([validationResult?.factoryInfo, validationResult?.senderInfo, validationResult?.paymasterInfo], keccakInputs)

  checkEntityInfo(entryPointAddress, userOp, entitySlots, 'factory', validationResult?.factoryInfo,
    callsFromEntryPoint.find(calls => calls.topLevelMethodSig === callMethodSig.factory),
    keccakInputs)

  checkEntityInfo(entryPointAddress, userOp, entitySlots, 'account', validationResult?.senderInfo,
    callsFromEntryPoint.find(calls => calls.topLevelMethodSig === callMethodSig.account),
    keccakInputs, validationResult?.factoryInfo)

  checkEntityInfo(entryPointAddress, userOp, entitySlots, 'paymaster', validationResult?.paymasterInfo,
    callsFromEntryPoint.find(calls => calls.topLevelMethodSig === callMethodSig.paymaster),
    keccakInputs)

  // return list of contract addresses by this UserOp. already known not to contain zero-sized addresses.
  const addresses = callsFromEntryPoint.flatMap(level => Object.keys(level.contractSize))
  const storageMap: StorageMap = {}
  callsFromEntryPoint.forEach(level => {
    Object.keys(level.access).forEach(addr => {
      storageMap[addr] = storageMap[addr] ?? level.access[addr].reads
    })
  })
  return [addresses, storageMap]
}

/**
 * check specific entity info
 * @param entryPointAddress
 * @param userOp
 * @param entitySlots
 * @param entityTitle
 * @param entStakes stakes of the entity under test
 * @param currentNumLevel
 * @param keccakInputs
 * @param factoryInfo (relevant only of current entity is account)
 */
// check specific entity
// entStakes - the entity to test
function checkEntityInfo (entryPointAddress: string, userOp: UserOperation, entitySlots: EntitySlots,
  entityTitle: string, entStakes: StakeInfo | undefined,
  currentNumLevel: TopLevelCallInfo | undefined, keccakInputs: string[], factoryInfo?: StakeInfo): void {
  const sender = userOp.sender.toLowerCase()

  const entityAddr = (entStakes?.addr ?? '').toLowerCase()
  if (currentNumLevel == null) {
    if (entityTitle === 'account') {
      // should never happen... only factory, paymaster are optional.
      throw new Error('missing trace into validateUserOp')
    }
    return
  }
  const opcodes = currentNumLevel.opcodes
  const access = currentNumLevel.access

  requireCond(!(currentNumLevel.oog ?? false),
    `${entityTitle} internally reverts on oog`, ValidationErrors.OpcodeValidation)
  Object.keys(opcodes).forEach(opcode =>
    requireCond(!bannedOpCodes.has(opcode), `${entityTitle} uses banned opcode: ${opcode}`, ValidationErrors.OpcodeValidation)
  )
  if (entityTitle === 'factory') {
    requireCond((opcodes.CREATE2 ?? 0) <= 1, `${entityTitle} with too many CREATE2`, ValidationErrors.OpcodeValidation)
  } else {
    requireCond(opcodes.CREATE2 == null, `${entityTitle} uses banned opcode: CREATE2`, ValidationErrors.OpcodeValidation)
  }

  Object.entries(access).forEach(([addr, {
    reads,
    writes
  }]) => {
    // testing read/write access on contract "addr"
    if (addr === sender) {
      // allowed to access sender's storage
      return
    }
    if (addr === entryPointAddress) {
      // ignore storage access on entryPoint (balance/deposit of entities.
      // we block them on method calls: only allowed to deposit, never to read
      return
    }

    // return true if the given slot is associated with the given address, given the known keccak operations:
    // @param slot the SLOAD/SSTORE slot address we're testing
    // @param addr - the address we try to check for association with
    // @param entitySlots - a mapping we built for keccak values that contained the address
    function associatedWith (slot: string, addr: string, entitySlots: { [addr: string]: Set<string> }): boolean {
      const addrPadded = hexZeroPad(addr, 32).toLowerCase()
      if (slot === addrPadded) {
        return true
      }
      const k = entitySlots[addr]
      if (k == null) {
        return false
      }
      const slotN = BigNumber.from(slot)
      // scan all slot entries to check of the given slot is within a structure, starting at that offset.
      // assume a maximum size on a (static) structure size.
      for (const k1 of k.keys()) {
        const kn = BigNumber.from(k1)
        if (slotN.gte(kn) && slotN.lt(kn.add(128))) {
          return true
        }
      }
      return false
    }

    debug('dump keccak calculations and reads', {
      entityTitle,
      entityAddr,
      k: mapOf(keccakInputs, k => keccak256(k)),
      reads
    })

    // scan all slots. find a referenced slot
    // at the end of the scan, we will check if the entity has stake, and report that slot if not.
    let requireStakeSlot: string | undefined
    const allSlots = [...Object.keys(writes), ...Object.keys(reads)]
    allSlots.forEach(slot => {
      // slot associated with sender is allowed (e.g. token.balanceOf(sender)
      // but during initial UserOp (where there is an initCode), it is allowed only for staked entity
      if (associatedWith(slot, sender, entitySlots)) {
        if (userOp.initCode.length > 2) {
          // special case: account.validateUserOp is allowed to use assoc storage if factory is staked.
          if (!(entityAddr === sender && isStaked(factoryInfo))) {
            requireStakeSlot = slot
          }
        }
      } else if (associatedWith(slot, entityAddr, entitySlots)) {
        // accessing a slot associated with entityAddr (e.g. token.balanceOf(paymaster)
        requireStakeSlot = slot
      } else if (addr === entityAddr) {
        // accessing storage member of entity itself requires stake.
        requireStakeSlot = slot
      } else {
        // accessing arbitrary storage of another contract is not allowed
        const readWrite = Object.keys(writes).includes(addr) ? 'write to' : 'read from'
        requireCond(false,
          `${entityTitle} has forbidden ${readWrite} ${nameAddr(addr, entityTitle)} slot ${slot}`,
          ValidationErrors.OpcodeValidation, { [entityTitle]: entStakes?.addr })
      }
    })

    // if addr is current account/paymaster/factory, then return that title
    // otherwise, return addr as-is
    function nameAddr (addr: string, currentEntity: string): string {
      // const [title] = Object.entries(stakeInfoEntities).find(([title, info]) =>
      //   info?.addr.toLowerCase() === addr.toLowerCase()) ?? []
      // return title ?? addr
      return addr
    }

    requireCondAndStake(requireStakeSlot != null, entStakes,
      `unstaked ${entityTitle} accessed ${nameAddr(addr, entityTitle)} slot ${requireStakeSlot}`)
  })

  if (entityTitle === 'paymaster') {
    // validatePaymasterUserOp returns (bytes,uint)
    // on empty context this is (structlen=0x40, byteslen=0x0, int-data), that is, exactly 32*3 = 96 bytes or 194 hex bytes
    const hasContext = currentNumLevel.output.length > 194
    requireCondAndStake(hasContext, entStakes,
      'unstaked paymaster must not return context')
  }

  // check if the given entity is staked
  function isStaked (entStake?: StakeInfo): boolean {
    return entStake != null && BigNumber.from(1).lte(entStake.stake) && BigNumber.from(1).lte(entStake.unstakeDelaySec)
  }

  // helper method: if condition is true, then entity must be staked.
  function requireCondAndStake (cond: boolean, entStake: StakeInfo | undefined, failureMessage: string): void {
    if (!cond) {
      return
    }
    if (entStake == null) {
      throw new Error(`internal: ${entityTitle} not in userOp, but has storage accesses in ${JSON.stringify(access)}`)
    }
    requireCond(isStaked(entStake),
      failureMessage, ValidationErrors.OpcodeValidation, { [entityTitle]: entStakes?.addr })

    // TODO: check real minimum stake values
  }

  // the only contract we allow to access before its deployment is the "sender" itself, which gets created.
  let illegalZeroCodeAccess: any
  for (const addr of Object.keys(currentNumLevel.contractSize)) {
    if (addr !== sender && currentNumLevel.contractSize[addr].contractSize <= 2) {
      illegalZeroCodeAccess = currentNumLevel.contractSize[addr]
      illegalZeroCodeAccess.address = addr
      break
    }
  }
  requireCond(
    illegalZeroCodeAccess == null,
      `${entityTitle} accesses un-deployed contract address ${illegalZeroCodeAccess?.address as string} with opcode ${illegalZeroCodeAccess?.opcode as string}`, ValidationErrors.OpcodeValidation)

  let illegalEntryPointCodeAccess
  for (const addr of Object.keys(currentNumLevel.extCodeAccessInfo)) {
    if (addr === entryPointAddress) {
      illegalEntryPointCodeAccess = currentNumLevel.extCodeAccessInfo[addr]
      break
    }
  }
  requireCond(
    illegalEntryPointCodeAccess == null,
      `${entityTitle} accesses EntryPoint contract address ${entryPointAddress} with opcode ${illegalEntryPointCodeAccess}`, ValidationErrors.OpcodeValidation)
}
